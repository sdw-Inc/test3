## 用語解説
**クライアント(Client):**データの所有者としてデータをブロックチェーンに保管しようとするノードを意味する。

**Farmer:**PCSN で基本ストレージスペースを持っているノードを意味する。

**Order:**PCSN には 2 つの市場つまりデータをアップロードする市場とデータを保管する市場が存在する。 
つまり価格の側ではでデータをアップロードする価格とデータを保管する価格が存在することになる。これに対する配置を order という。 

**Kardemila:**分散化された p2p ネットワークで分散ハッシュのテーブルである。Kardemila のノードは合い互いに UDP の通信を進行する。すべてのノードは NodeID で識別されるし NodeID は識別子だけでなく保存された位置情報を持っている。つまり NodeID はファイルのハッシュと連結されてファイルがどこに保管されているかに関する情報を持っていることになる。

## POSTT A Peer-to-Peer Cloud Storage Network

### 概要
クライアント側の暗号化を具現した PCSN(P2P Cloud Storage Network)はユーザが第 3 者のストレージスペースに依存しなくてデータを伝送して共有できるようにしている。

中央コントロールの除去は急激に増加するセキュリティとプライバシーそしてデータのコントロールだけではなく伝統的なデータのエラーと停電のような問題を緩和させることができる。 

以前には P2P ネットワークが保存システムの構築には適わなかった。 

このシステムでは直接支払と結び付いた試み-回答検証システムのような形態で問題点を提案する。 

この時にシステムはデータの真実性を定期的に検査することができるし、peer にデータの保管に対する対価を支払うことができる。 

このシステムはまたアドレスのアクセスモデルと独立或いはノードの集合の性能について提案する。 

### 紹介 
クラウドストレージはデータの保管と転送のために検証された第 3 者の機関と同じような役割をする大容量ストレージスペースを提供するのに利用されて来た。

しかしこのシステムは trust-based モデルという問題点を含んでいる。

それはクライアント側の暗号化は一般的ではなくまた伝統的なクラウドは malware とかサーバのプログラムの問題を利用してハッカーによって個人的なデータが流失される出来る問題点を持っているからである。

また多くのストレージのサーバは同じ基盤に依存しているために大きい問題点はファイルを通じてシステムの全般に影響を及ぶことが出来る。

分散化されたストレージのネットワークはサーバ中心の基盤のクラウドストレージのシステムに比べて多い良さを提供する。

データの安全性はクライアント側の暗号化によって維持されるしデータの真実性は回復力の証明によって維持されることである。

サーバの誤動作とセキュリティ違反の影響は大きく減ることになることである。

データのストレージスペースに対して市場で使用されるストレージのためのデバイス間に競争をすることでより多くのデバイスが投入されるようになるし、それによって価格はますます安くなる。

ネットワークのデータは不当の変更、承認されていないアクセスとかデータのエラーに対する強い抵抗力を持つようになるだろう。

下記ではこのような部分について記述することにする。

## 01.POSTT プロトコルの概要

POSTT プロトコルはブロックチェーンとブロックチェーンで提供する独自コイン或いはトークンにより分散化されたクラウドストレージネットワークを実現することである。つまりクライアントはデータの保存やダウンロードのためにトークンを転送し、マイナーはデータの保存とデータのサービスに使われているコイン或いはトークンをマイニングすることになる。

POSTT 分散化されたドストレージネットワークは 2 つの市場を通じてデータの保存とデータのダウンロード機能を遂行することができる。 2 つの市場はデータの保存市場とデータのサービス市場である。クライアントとマイナーはそ価格を決めて市場で order を形成するしそれぞれの order を処理する方式で進められる。

この市場は POS(Proof of Space)と POTT(Proof of Time and Transaction)を具現した POSTT によって運営されるし、ユーザは自分のデータを安全的に定められた時間の間に保存できるようになる。

最後にマイナーはブロックチェーンで新しいブロックを生成してブロックチェーンを維持することになる。 新しいブロックに対するマイナーの影響力つまりマイナーとして当選される選択率はネットワークで使用される現在までのストレージスペースと時間そして取引の個数に比例することになる。

## 02.PCSN に対する定義
PCSN は独立的なストレージスペースを総括して一つの巨大なストレージスペースを P2P を通じて構築することを目的とする。

すなわちユーザはこのような独立的なストレージスペースを効果的に利用としてデータの保管と利用で費用を減らし torrent の良さを生かし、データの伝送帯域幅を最大限に高めることができるようにシステムを構築としてユーザの便宜を保する目的で構成されることである。

PCSN は中央的なストレージクラウドとは違って第 3 者の信頼する機関が存在しないために P2P に存在するさまざまな問題すなわち Byzantium Generals 問題などのようなシステムへの依存性問題が存在することになる。

すなわちこのような問題点を解決するためにビットコインで利用する作業証明(Proof of work)と同じような理論的な問題を結合することによって対策している。

PCSN プロトコルの構造は下記のようである。

*Write(data)->Key:*ユーザは唯一の識別子 Key によってデータを保管するために write プロトコルを利用する。

*Read(Key)->data:*ユーザは Key を利用して現在保存されているデータをダウンロードするために Read プロトコルを利用する。

*Operate():*このプロトコルはブロックチェーンを維持するための様々な機能を含むようになる。 使用可能なストレージスペースのコントロールと Farmer によって提供されるサービスそして様々なエラーの処理機能などを含むようになる。 この機能は大体に Farmer によって利用されることもある。

### 2.1 エラーの許容範囲 
#### 2.1.1. Operate エラーの許容範囲 
これはビザンチウム(Byzantium)の問題に帰着されるようになる。 

PCSN のエラーの許容範囲は Operate のエラーの許容範囲に帰着されるようになる。 

それは Operate が PCSN の全般的なネットワーク関連問題を含めるからである。 

PCSN は POSTT によってビザンティウム(Byzantium)の問題を解決するように構成された。

POSTT はストレージスペースと時間、取引履歴によってブロックを生成するようになっている。ここで非正常的なノードの数を f としてマイナーの数を n としている時にブロックチェーンの安全のためには少なくとも f はn/2 より小さくなければならない。 

#### 2.1.2. 保存スペースのエラーの許容範囲 
このシステムははストレージスペースのエラーの許容についてビザンティウム(Byzantium)のエラーによってユーザがデータのサービスを受けられないことに定義することができる。
 
Farmer はデータの切れ端(shard)を失うことが出来る。そんな場合その 切れ端に対するサービス(ダウンロードとか)をすることができなくなる。

すなわちすべてのファイルの切れ端は少なくとも一つ以上の正常のノードに保管されなければならない。

すなわちこのような問題点があるためにデータの切れ端の 70%だけあってもデータ修復可能なアルゴリズムを具現して約 30%が損失されても全体のデータの修復を可能にするアルゴリズムを実現しようとしている。

## 3. デザイン(Design)
PCSN は peer の間にストレージコントラクト(storage contract)の形成と実行するために分散ネットワークを創造するプロトコルである。

PCSN プロトコルはネットワークの peer の間に交渉のコントラクト、データの転送、真実性の検証、リモートデータ或いは受け取ったデータの有効性と他のノードに支払う方式を実装する。

それぞれの peer は独立的な代理人であるし相互の直接な接触がなくてもこのようなアクションを可能にしてくれる。

このような相互作用のための基礎的な内容がこの文書で書かれている。

### 3.1 暗号化された切れ端のファイル(Files as Encrypted Shards)
切れ端はネットワークに保管される暗号化されたファイルの一部である。

切れ端はセキュリティ、プライバシー、性能と有効性で多くの良さを持っている。

ファイルは分割される前にクライアント側で先に暗号化される。
 
この部分は AES256-CRT を利用しているしそこに極限暗号化(limit cryptography)或いは必要な他のシステムが具現されることもできる。

これはストレージスペースの提供者である Farmer からデータを保護する。データの所有者は暗号化のキーを利用してデータのアクセスとコントロールすることができる。 

データの所有者はファイルをどのように分割するのかと切れ端がどこに保管されるかを管理することができる。

切れ端の数が増えれば増えるほど暗号化のキーがなければその切れ端がどこに保管されているかを探すのが困難になる。

ファイルのセキュリティはネットワークの大きさに比例することになる。

切れ端の大きさは設定可能なコントラクトのパラメーターである。プライバシーを保護するためには切れ端の大きさが 8 MB の倍数つまり 8 MB 或いは 16MB 、32MB になることがいいである。

残った部分は 0 或いは任意のデータで満たされることになる。

もしファイルのサイズが大きなビデオのようなファイルはノードに分割されて保管されながら該当するノードに対して伝送で負荷を減らしてくれる

つまり帯域幅で bittorrent と同じ効果を出るようにしている。 

有効性はデータを保管しているノードの数によって担保される。

![MODULE]({{ baseurl }}/images/logo.png")

1.	ファイルは暗号化される。
2.	暗号化されたファイルは 切れ端に分離されたり或いは様々なファイルが一つの切れ端に統合される。
3.	個々の 切れ端に対する検証する。
4.	切れ端はネットワークへ転送される。

### 3.2 Kademlia アルゴリズムと更新 
PCSN は Kademlia アルゴリズムすなわち a Distributed Hash Table(DHT)を利用している。

切れ端がハッシュのテーブルに保管されていないということは重要なことである。

とにかく Kademlia はメッセージのルーティングと他の機能を提供する分散されたネットワークを創造する。 

PCSN は色々なメッセージの形式を追加して Kademlia の機能を向上させる。

これからハッシュのテーブルはデータの location 情報と他の目的に使われるようになる。 

### 3.3 署名確認(Signature Verification) 
Kademlia と似ているが PCSN は peer が自分でメッセージを検証することを要求する。

ネットワークに連結するためにノードは ECDSA キーのペア(Kpriv、Kpub)を生成しなければならない。

Kademlia ノード ID は ripemd160(sha256(Kpub))と関係される。

上記で分かるように PCSN ネットワークのノード ID はノードが送ることができるビットコインのアドレスに似ている。

ノードはすべてのメッセージをサインするしメッセージを処理する前にはメッセージのサインを検証する。

修正はネットワークで長い時間を必要にするし、Kademlia ルーティングに対して攻撃することを防ぐために作業証明を提供する。これからこのアドレスを利用する他の変種が出る可能性がある。

### ファイルの安全性と回復力の証明
ファイルの安定性と回復力の証明というのはリモートのノードに存在する特定の切れ端のデータが正確だということを証明するものである。最も完璧な証明メッセージの最小サイズは前処理を通して早く計算されることになるしまたファイルの使用性を最上の信頼で提供する。

データの所有者にデータの真実性と使用性に対する情報を提供するために PCSN は audit 或いはheartbeat と呼ぶ challenge-response interaction によって回復力の証明を検証する標準形式を提供する。

このシステムはマークル木(Merkle Tree)とマークル(Merkle)証明を使用する。 データの切れ端化の工程後データの所有者は n 個の任意の乱数 s0、s1…sn-1 を生成するしそれを保管する。

```
P(i) = H( S(i) + d )
```
 
D はデータ、P は pre-leaf、H はハッシュの関数である。

これはマークル木に対する説明である。

つまり葉(leaf)の項目 P(i)を合わしてそれを利用して再び L(i)を作る。その方式でハッシュを繰り返してルート(root)を得ることになる。

![MODULE](http://i.imgur.com/logo.png)

つまりデータの所有者はマークルのルートの値とマークル木の等級(degree)、s0~sn-1 までを保管するしその次はマークル木の葉項目を Farmer(データを保管するノード)に伝送する。

Farmer は 切れ端と葉を保管する。定期的にデータの所有者は保存の会合から Challenge 中の一つを選択して Farmer にそれを伝送する。Challenge はどんなパターンにより選択されるが再び利用されない。 Farmer は pre-leaf を作るために challenge とデータを使用する。

葉と同様に Pre-leaf はデータの所有者に再度戻ってくるマークル証明を生成するために利用される。 
PCSN マークル証明はいつも log2(|L|)+1 個のハッシュを持つことになる。データの所有者は保管されたマークルのルートとマークル木の等級を利用しているが、それはそれの長さがマークル木の等級と同じでハッシュがルート(root)と同じだということを検証することに利用する。
 
### 3.4　部分的な監査(Partial Audits)
マークル木の audit 形式はデータの所有者にとって pre-leave を生成するために多くのハッシュ演算を遂行しなければならないことを要求する。この形式の拡張として部分的な検証を遂行するためにデータの一部を選択することとして計算量を減少させる。

この形式は 2 つの追加的なパラメーターに依存する。

切れ端のバイトインデックス x の会合とセクション長さ b の会合である。 

データの所有者は(s、x、b)の会合を保管する。I 番目の pre-leaf を生成するためにデータの所有者は Si、 bi、xi を準備する。Audit を実行する間に検証者は Farmer が pre-leaf を作るに利用される(s、x、b)i を伝送する。マークル証明は一般的な方法でつくられて検証される。

Partial audit はただ Farmer が全体のファイルを保管しているという事実のみを提供する。 
とにかくデータの所有者はデータの切れ端が存在して使用できるということをしなければならない。 

### 3.5 発行監査(Issuing Audits) 
Audits を検証するために PCSN は新しい形式の Kademlia メッセージを拡張する。 

このメッセージはデータの所有者から Farmer に送信されてデータのハッシュと challenge を含んでいる。
 
Farmer は上記で説明したマークル証明に対して回答しなければならない。回答を受ければマークル証明を検証してデータの所有者は Farmer に支払わなければならない。

![MODULE](http://i.imgur.com/logo.png)

### 3.6 コントラクトと交渉 
データのストレージスペースは標準のコントラクト(contract)形状によって交渉される。コントラクトはバージョン化されたデータの構造であるがデータの所有者と Farmer の関係を表現する。コントラクトは個々のノードに対して必要なすべての情報を保管しなければならないが、そのような情報では関係、データの転送、auditの創造と応答時間と支払いの方法などが含まれる。 これは 切れ端のハッシュ、 切れ端のサイズ、audit の計画と支払い情報等を含んでいる。

### 3.7 支払いの方式 
このシステムでは自体のコインとして支払方式を定義する。

現在は内臓コイン或いはトークンで支払いを考えているが、btc とか eth と同じコインでも可能とすることを目標にしている。

## 4. PoSTT(Proof of Space and Proof of Time and Transaction)
PCSN で Farmer はクライアントのデータを保管しなければならない責任を持ってクライアントはそれに対する補償しなければならない。

Farmer は POSTT を利用してブロックチェーンのネットワークを検証する。

### 4.1 概要 
POS 形式は PDP(データの所有の証明、Provable Data Possession)と POR(Poof of Retrievability)の形式と同じであるがそれはユーザがサーバーにあるデータを定期的に検査することとしてサーバーにデータを委託することが可能にしている。

ユーザはデータをダウンロードしなくてもサーバーにあるデータが正確だということを検証することができる。

ここでいうサーバーはデータを保管しているノードである。

サーバーは任意のブロックの会により確率論的に所有権証明を生成してユーザとデータの一部をやりとりしながらハンドシェイクを進行する。

PDP と POR の形式はハンドシェイクを通じてその時間にデータを保管しているということを検証するプロトコルに見ることができる。POSTT で防がなければならない問題はデータのストレージスペースを提供せずにブロ ックを生成する非法マイナーらの攻撃を防止することである。 そのような攻撃としては下記のようなものが存在する。

*Sybil の攻撃：*非法マイナーはマイニングに成功するために一つのデータをコピーして重複 SybilID を生成することとして実際のデータを保管しているノードよりもっとたくさん保管しているように偽造してマイニングに成功することができる。

*Outsourcing の攻撃：*非法マイナーは他のマイナーからデータを早く集めてくることに依存して実のマイナーが物理的に保存できるスペースより多くのデータを保存することとしてマイニングに成功することができる。 

*Generation の攻撃：*非法マイナーは小さなプログラムを代わりに使用して効率的に注文型データを生成していると見ることができる。 

### 4.2 PORep(Proof of Replication)について 
PORep は POS であるがサーバーがユーザにデータがストレージスペースにコピーされたことを確信させるプロトコルである。この形式は相互作用のプロトコルで見られるが証明者 P はデータの切れ端を保管して検証者にデータを正確に保管したということをハンドシェイクを通じて確信させる形式である。

つまり PORep は POR と PDP を発展させて Sybil の攻撃、Outsourcing の攻撃と Generation の攻撃を防ぐことができるように構成された。

PORep に対する定義は下記の通りである。

PORep の形式は証明者 P が検証者 V に P がデータ D の物理的及び独立的なコピーした R を保管しているということを確信させることができるようにしてくれるというわけである。

PORep は次のような 3 つの因子に構成される多項式-時間のアルゴリズムである。
つまり Setup、Prove と Verify と見ることができる。
 
ここにゼロ知識証明を導入することになる。

つまり Setup は P(Prove)、V(Verify)と R(Replica)を生成するし P と V は証明と検証に利用されるパラメ ーターと見ることができる。 Setup はシステムが構築される時第 3 者の信頼できる機関によって作られる。

Prove は検証者にデータのコピーR にアクセス可能することを証明するのに必要な Proof を生成する。

Verify は Proof をパラメーターとして証明者が R にアクセスできるかどうかを検証することになる。

### 4.3 Proof of Spacetime and Transaction 
Proof of Space の形式はユーザに Farmer が該当の時間にデータを保管しているかを検査できるようの機能を提供している。そればこのシステムでどのようにして POS を利用してデータが一定期間に保管されかを証明することができようか。この質問に対する一般的な答えはユーザが Farmer に一定の時間周期に継続challenge を送って調べる方法である。このような場合にはメッセージの量が多くなるしボトルネックの現象をはじめてネットワークの負荷を起こルカ脳性がある。

この問題に対応するためにこのシステムでは新しい Proof of Space Time and Transaction という証明システムを導入して検証者が証明者が当該の時間の間にデータを正確に保管しているのかを検査できるように提供している。

POST は証明者 P が検証者 V に P がデータ D を T 時間の間に保存したことを証明できるようにするプロトコルである。

POST の構成は次のとおりである。

つまり Setup、Prove、Verify と見ることができる。

ここも同様にゼロ知識証明を導入することになる。

つまりゼロ知識証明を導入してデータの情報を流出しなくてユーザは Farmer からデータの真実性を確認することができる。

### 4.4 ZK-SNARKS について 
どんな文章に対して真実であることを証明する側を証明者(prover)として証明過程に参加して証明者と情報をやりとりする方を検証者(verifier)という。

ゼロ知識証明に参加する当事者が存在する場合検証者を騙す目的でプロトコルを変更しようとする場合当事者が不正直という。その他の場合には正直という。

ゼロ知識証明は次のような三つの機能を満足させなければならない。 

1. 完全性：どんな文章が真実であれば正直な証明者は正直な検証者に事実を納得させることができる。 
2. 健全性：どんな文章が虚偽ならどのような不正直な証明者でも正直な検証者に事実を納得させることはできない。 
3. ゼロ知識性：どんな文章が真実であれば検証者は文章の真実と虚偽に以外には何も知りできなければならない。

